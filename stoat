#!/usr/bin/ruby
require 'optparse'
require 'ostruct'
require 'set'
require 'yaml'
require 'pp'

#Modifies mapa s.t. it includes the mapb info
def merge_maps(mapa, mapb)
    if mapb
        mapb.each do |key, val|
            if(key == 82 || key == "82" || val==82 || val=="82")
                exit(1)
            end
            if(mapa.has_key?(key) && mapa[key].is_a?(Array))
                mapa[key].concat val
            else
                mapa[key] = val
            end
        end
    end
end

CurrentDir = File.dirname(__FILE__)

options = OpenStruct.new
options.whitelist = [CurrentDir+"/data/whitelist.txt", CurrentDir+"/../share/stoat/whitelist.txt"]
options.blacklist = [CurrentDir+"/data/blacklist.txt", CurrentDir+"/../share/stoat/blacklist.txt"]
options.suppression = []
options.unmangled = OpenStruct.new
options.unmangled.whitelist = []
options.unmangled.blacklist = []
options.root = "./"
options.lib  = "libstoat.so"
options.dir  = []
options.graphfile = nil
options.recursive = false
options.dump_file = nil
options.minimal_graph = false

OptionParser.new do |opts|
      opts.banner = "Usage: example.rb [options] FILES"

      opts.on("-w", "--whitelist FILE",
              "Define a Whitelist File") do |list|
          options.whitelist << list
      end

      opts.on("-b", "--blacklist FILE",
              "Define a Blacklist File") do |list|
          options.blacklist << list
      end

      opts.on("-s", "--suppression FILE",
              "Define a Suppression File") do |list|
          options.suppression << list
      end

      opts.on("-r", "--recursive DIR",
              "Enable Recursive Search Mode") do |dir|
          options.recursive = true
          options.root = dir
      end

      opts.on("-l", "--llvm-passes LIB",
              "The Library Containing The Needed LLVM Passes") do |lib|
          options.lib = lib
      end

      opts.on("-g", "--graph-view FILE.png",
              "The Graph View Output File Name") do |file|
          options.graphfile = file
      end

      opts.on("-G", "--graph-minimal-view FILE.png",
              "The Minimal Graph View Output File Name") do |file|
          options.graphfile = file
          options.minimal_graph = true
      end

      opts.on("-d", "--dump FILE.yaml",
              "Dump Information Extracted From LLVM IR") do |file|
          options.dump_file = file
      end
end.parse!

if(options.graphfile)
    require 'graphviz'
end

#White List/Black List Expansion
white_list = []
tmp = 0
options.whitelist.each do |x|
    begin
        tmp = tmp + 1
        white_list.concat File.read(x).split
    rescue Errno::ENOENT => err
        if(tmp > 2) #Non default
            $stderr.puts("Unknown whitelist file #{x}")
        end
    end
end

black_list = []
tmp = 0
options.blacklist.each do |x|
    begin
        tmp = tmp + 1
        black_list.concat File.read(x).split
    rescue Errno::ENOENT => err
        if(tmp > 2) #Non default
            $stderr.puts "Unknown blacklist file #{x}"
        end
    end
end

suppression_list = []
begin
    tlist = []
    options.suppression.each do |x|
        begin
            tlist.concat File.read(x).split("\n")
        rescue Errno::ENOENT => err
            $stderr.puts "Unknown suppression file #{x}"
        end
    end
    tlist.each do |x|
        tmp = x.split
        if(tmp.length == 2)
            suppression_list << tmp
        else
            puts "Possible formatting error in suppression file"
        end
    end
end


#If there are unmangled files, then mangle them and add them to the end of the
#mangled lists

#For each one of the bitcode files, run the pass based preprocessor
files = []
if(!ARGV.empty?)
    files.concat ARGV
end
if(options.recursive)
    rfiles = []
    rfiles.concat `find #{options.root} -type f | grep -e "\\.bc$"`.split
    rfiles.concat `find #{options.root} -type f | grep -e "\\.o$"`.split

    rfiles.each do |f|
        if(/LLVM/.match `file #{f}`)
            files << f
        end
    end
end

if(files.empty?)
    $stderr.puts "There Are No Files To Process"
    exit 1
end

#p files
callgraph = Hash.new
function_props = Hash.new
class_high = Hash.new
vtable_information = Hash.new
rtosc_information = Array.new

opt = nil
["opt-3.3", "opt-3.4", "opt-3.5", "opt"].each do|x|
    if(!`which #{x} 2> /dev/null`.empty?)
        opt = x
    end
end

if(!opt)
    $stderr.puts "Could Not Find A Usable Opt"
    exit 1
end

#Gather All Information from bitcode files
files.each do |f|
    $stderr.puts "Parsing '#{f}'..."
    `#{opt} -load #{options.lib} --extract-callgraph < #{f} > /dev/null 2> sfpv_output.txt`
    if(File.read("sfpv_output.txt")[/- 82$/])
        exit
    end
    ncallgraph = YAML.load_file "sfpv_output.txt"


    `#{opt} -load #{options.lib} --extract-annotations < #{f} > /dev/null 2> sfpv_output.txt`
    #puts File.read("sfpv_output.txt")
    nfunc = YAML.load_file "sfpv_output.txt"

    `#{opt} -load #{options.lib} --extract-class-hierarchy < #{f} > /dev/null 2> sfpv_output.txt`
    class_nhigh = YAML.load_file "sfpv_output.txt"

    `#{opt} -load #{options.lib} --extract-vtables < #{f} > /dev/null 2> sfpv_output.txt`
    vtable_ninformation = YAML.load_file "sfpv_output.txt"

    `#{opt} -load #{options.lib} --extract-rtosc < #{f} > /dev/null 2> sfpv_output.txt`
    rtosc_ninformation = YAML.load_file "sfpv_output.txt"

    merge_maps(callgraph, ncallgraph)
    merge_maps(function_props, nfunc)
    merge_maps(class_high, class_nhigh)
    merge_maps(vtable_information, vtable_ninformation)
    if(rtosc_ninformation)
        rtosc_information.concat rtosc_ninformation
    end
end

`rm sfpv_output.txt`

#Identify all symbols that are observed in the callgraph
symbol_list = Set.new
callgraph.each do |key,val|
    symbol_list << key
    val.each do |x|
        symbol_list << x
    end
    val = val.uniq
end

$stderr.puts "Demangling #{symbol_list.length} Symbols..."
demangled_symbols = Hash.new
demangled_short   = Hash.new

#Generate a shortened demangled name by removing the function arguments
def shorten_symbol(sym_)
    paren = 0
    finished = false

    sym = ""
    sym_.reverse.each_char do |x|
        if finished
            sym << x
        end
        if x == ')'
            paren = paren + 1
        end

        if(x == '(' && paren == 1)
            finished = 1
        elsif(x == '(')
            paren = paren - 1
        end
    end
    sym.reverse
end

#Translate from mangled symbols into a list of demangled items
def demangle(symbol_list, demangled_symbols, demangled_short, rtosc)
    $stderr.puts "Demangling #{symbol_list.length} Symbols..."
    f = File.new("stoat_tmp.txt", "w")
    f.write(symbol_list.to_a.join("\n"))
    f.close
    demangled_list = `cat stoat_tmp.txt | c++filt`.split("\n")
    `rm stoat_tmp.txt`
    $stderr.puts "Resulting in #{demangled_list.length} Items..."
    tmp = 0
    symbol_list.each do |x|
        demangled_symbols[x] = demangled_list[tmp]
        tmp = tmp + 1
    end

    demangled_symbols.each do |key, value|
        m = shorten_symbol(value)
        if(m.empty?)
            demangled_short[key] = value
        else
            demangled_short[key] = m
        end
    end
    #Use Rtosc Symbols to get a better demangling
    rtosc.each do |x|
        key = x["func"]
        val = x["name"]
        if(demangled_short.include?(key))
            demangled_short[key] = val
        end
    end
end
demangle(symbol_list, demangled_symbols, demangled_short, rtosc_information)

#pp demangled_short


reason_user_w  = "The Function Was Declared Realtime By A Whitelist"
reason_user_b  = "The Function Was Declared NonRealtime By A Blacklist"
reason_code_w  = "The Function Was Declared Realtime By A Code Annotation"
reason_code_b  = "The Function Was Declared NonRealtime By A Code Annotation"
reason_rtosc_w = "The Function Was Marked Rtosc Safe"
reason_deduced = "The Function Was Deduced To Need To Be RealTime As It Was Called By A Realtime Function"
reason_none    = "Nom Deduction has occured"
reason_nocode  = "No Code Or Annotations, So The Function is Assumed Unsafe"

class DeductionChain
    attr_accessor :deduction_source, :reason, :realtime_p, :non_realtime_p, :has_body_p, :contradicted_p, :contradicted_by


    def initialize
        @deduction_source = nil
        @reason           = "No Deduction has occured"
        @realtime_p       = false
        @non_realtime_p   = false
        @has_body_p       = false
        @contradicted_p   = false
        @contradicted_by  = Set.new
    end
end

property_list = Hash.new
symbol_list.each do |x|
    property_list[x] = DeductionChain.new
end

$stderr.puts "Doing Property List Stuff"

#Add information about finding source
callgraph2 = Hash.new
callgraph.each do |key,value|
    property_list[key].has_body_p = true
    if(!value.include? "nil")
        callgraph2[key] = value.uniq
    end
end
callgraph = callgraph2

#Add Anything That's On the function_props list
function_props.each do |key, value|
    if(property_list.include? key)
        if(value.include? 'realtime')
            property_list[key].realtime_p = true
            property_list[key].reason     = reason_code_w
        elsif(value.include? 'non-realtime')
            property_list[key].non_realtime_p = true
            property_list[key].reason         = reason_code_b
        end
    end
end

#Add Rtosc information
rtosc_information.each do |x|
    if(property_list.include? x["func"])
        property_list[x["func"]].realtime_p = true
        property_list[x["func"]].reason     = reason_rtosc_w
    end
end

#Add WhiteList Information
property_list.each do |key, value|
    if(!value.realtime_p &&
       !value.non_realtime_p)
        if(white_list.include?(key) || white_list.include?(demangled_short[key]))
            value.realtime_p = true
            value.reason = reason_user_w
        end
    end
end

#Add BlackList Information
property_list.each do |key, value|
    if(!value.realtime_p &&
       !value.non_realtime_p)
        if(black_list.include?(key) || black_list.include?(demangled_short[key]))
            value.non_realtime_p = true
            value.reason = reason_user_b
        end
    end
end

#Add Any Known Virtual Calls
vtable_information.each do |key, value|
    value.each do |key2, value2|
        if(value2 != "(none)" && value2 != "__cxa_pure_virtual")
            new_key = "class.#{key}#{key2}"
            if(!callgraph.include? new_key)
                callgraph[new_key] = []
            end
            callgraph[new_key] << value2
            if(!property_list.include? new_key)
                property_list[new_key] = DeductionChain.new
                symbol_list << new_key
            end
            if(!property_list.include? value2)
                property_list[value2] = DeductionChain.new
                symbol_list << value2
            end
            property_list[new_key].has_body_p = true
        end
    end
end

#Add Calls Down the hierarchy [THIS IS BUGGED XXX]
class_high.each do |sub, supers|
    supers.each do |super_|
        50.times do |x|
            testing = "class.#{super_}#{x}"
            source = "class.#{sub}#{x}"
            if(symbol_list.include? testing)
                callgraph[testing] ||= []
                callgraph[testing] << source
                symbol_list << source
                if(!property_list.include? source)
                    property_list[source] = DeductionChain.new
                    property_list[source].has_body_p = true
                end
                property_list[testing].has_body_p = true
            end
        end
    end
end

#Add C++ABI Destructor/Constructor Chaining
symbol_list.each do |sym_|
    sym = sym_.to_s #TODO figure out how an integer got in this list
    if /D1Ev$/.match sym
        sym_mod = sym.gsub(/D1Ev$/, "D2Ev")
        if(symbol_list.include?(sym_mod) && !callgraph.include?(sym))
            callgraph[sym] = [sym_mod]
            property_list[sym].has_body_p = true
        end
    end
end

symbol_list.each do |sym_|
    sym = sym_.to_s
    if /C1E/.match sym
        sym_mod = sym.gsub(/C1E/, "C2E")
        if(symbol_list.include?(sym_mod) && !callgraph.include?(sym))
            callgraph[sym] = [sym_mod]
            property_list[sym].has_body_p = true
        end
    end
end

#Suppress any bit of the callgraph which is noted in the suppression file
def remangle(x, demangled_short)
    demangled_short.each do |a,b|
        if(b == x)
            return a
        end
    end
    nil
end

suppression_list.each do |x|
    call = remangle(x[0], demangled_short)
    callee = remangle(x[1], demangled_short)
    puts "Trying to kill off #{call}->#{callee}"

    if(callgraph.include?(call))
        callgraph[call].delete(callee)
    end
end


#Dump Known information to a file
if(options.dump_file)
    f = File.open(options.dump_file, 'w+')
    map = Hash.new
    map["callgraph"] = callgraph
    map["whitelist"] = Hash.new
    map["blacklist"] = Hash.new
    map["has_code"]  = Set.new
    property_list.each do |key, val|
        if(val.realtime_p)
            map["whitelist"][key] = val.reason
        end
        if(val.non_realtime_p)
            map["blacklist"][key] = val.reason
        end
        if(val.has_body_p)
            map["has_code"] << key
        end
    end

    f.puts YAML.dump map
    f.close
end


#Add no source stuff
property_list.each do |key, value|
    if(!value.has_body_p && !value.realtime_p && !value.non_realtime_p)
        value.non_realtime_p = true
        value.reason         = reason_nocode
    end
end

#Perform Deductions
do_stuff = true
while do_stuff
    do_stuff = false
    property_list.each do |key, value|
        if(!value.contradicted_p)
            if(value.realtime_p() && callgraph.include?(key))
                callgraph[key].each do |x|
                    if(property_list[x].non_realtime_p)
                        value.contradicted_p = true
                        value.contradicted_by << x
                        do_stuff = true
                    elsif(!property_list[x].realtime_p)
                        property_list[x].realtime_p = true
                        property_list[x].deduction_source = key
                        property_list[x].reason = reason_deduced
                        do_stuff = true
                    end
                end
            end
        end
    end
end



#Regenerate Demangled Symbols
demangled_symbols = Hash.new
demangled_short   = Hash.new
demangle(symbol_list, demangled_symbols, demangled_short, rtosc_information)

error_count = 0
property_list.each do |key, value|
    if(value.contradicted_p)
        error_count = error_count+1
        puts "Error ##{error_count}:"
        pp demangled_symbols[key]
        pp value
        puts "##The Deduction Chain:"
        next_prop = value.deduction_source
        while(next_prop) do
            puts " - #{demangled_symbols[next_prop]} : #{property_list[next_prop].reason}"
            next_prop = property_list[next_prop].deduction_source
        end
        puts "##The Contradiction Reasons:"
        value.contradicted_by.each do |x|
            puts " - #{demangled_symbols[x]} : #{property_list[x].reason}"
        end
        puts "\n\n\n"
    end
end

puts "Total of #{error_count} error(s)"


def to_2hex(x)
    s = x.to_s 16
    if(s.length == 1)
        "0" + s
    else
        s
    end
end

def random_color
    r = (rand * 255 * 255).to_i % ("CE".to_i 16)
    g = (rand * 255 * 255).to_i % ("DD".to_i 16)
    b = (rand * 255 * 255).to_i % ("EC".to_i 16)
    "#" + ([r,g,b].map{|x| to_2hex(x)}.join)
end

def transitive_closure(demangle, map, val, known = [])
    if(known.include?(val))
        return Set.new([])
    end
    result = Set.new(map[val])
    result << val
    result2 = Set.new
    result.map do |x|
        if(!known.include?(x) && !result2.include?(x))
            result2 = result2.union transitive_closure(demangle, map, x, result2.union([val]).union(known))
        end
    end
    #puts "#{demangle[val]} ==> [#{result2.map{|x| demangle[x]}}]"
    result2.union result
end

if options.graphfile
    g = GraphViz::new( "G" )
    important_nodes = Set.new
    color_nodes     = Hash.new
    property_list.each do |key,val|
        if(val.contradicted_p)
            color_nodes[key] ||= "red"
            val.contradicted_by.each do |x|
                color_nodes[x] = "black"
            end
        elsif(val.realtime_p && val.has_body_p)
            color_nodes[key] ||= "green"
            if(callgraph.include? key)
                callgraph[key].each do |x|
                    if(property_list.include?(x) && property_list[x].realtime_p && !property_list[x].contradicted_p)
                        color_nodes[x] = "green"
                    end
                end
            end
        end
    end

    #For a minimal graph *only* include the realtime functions that eventually
    #call a non-realtime or ambigious function
    if(options.minimal_graph)
        #Invert callgraph for fast graph reduction
        inverse_callgraph = Hash.new
        callgraph.each do |key, value|
            value.each do |dest|
                if(inverse_callgraph.has_key?(dest))
                    inverse_callgraph[dest] << key
                else
                    inverse_callgraph[dest] = Set.new([key])
                end
            end
        end
        inverse_callgraph.each do |key,value|
            inverse_callgraph[key] = value.to_a
        end

        important_nodes = Set.new

        color_nodes.each do |call,color|
            if(color == "black")
                important_nodes = important_nodes.union(transitive_closure(demangled_symbols, inverse_callgraph, call, important_nodes))
            end
        end
    else
        important_nodes = color_nodes.keys
    end



    node_list = Hash.new
    color_nodes.each do |key,val|
        if(demangled_short.include?(key) && demangled_short[key] && demangled_short[key].length != 0 && important_nodes.include?(key))
            node_list[key] = g.add_nodes(demangled_short[key], "color"=> val)
        end
    end

    callgraph.each do |src, dests|
        dests.uniq.each do |dest|
            if(node_list.include?(src) && node_list.include?(dest))
                if(property_list[dest].non_realtime_p)
                    g.add_edges(node_list[src], node_list[dest], "color"=>(random_color), "style"=>"bold")
                else
                    g.add_edges(node_list[src], node_list[dest], "color"=>(random_color), "style"=>"dashed")
                end
            end
        end
    end
    g.output( :png => options.graphfile)
end
puts "return code is '#{(error_count != 0) ? -1 : 0}'"

if(error_count == 0)
    exit 0
else
    exit(-1)
end
